関数型プログラミング言語Haskellでは圏論的な視点からライブラリが構築されている.
\section{型}
\subsection{定義済みの型}
Haskellには標準ライブラリに表3.1に示す型が定義済みである.
\begin{table}[h]
\caption{Haskellの標準ライブラリに定義済みの型}
\begin{center}
\begin{tabular}{ll}
\verb|Int|&固定長整数\\
\verb|Integer|&多倍長整数 \\
\verb|Char|&文字\\
\verb|Float|&単精度浮動小数点数\\
\verb|Double|&倍精度浮動小数点数\\
\verb|Bool|&ブール代数\\
\end{tabular}
\end{center}
\end{table}

例として, 固定長整数の変数\verb|a|は次のように宣言する.
\begin{lstlisting}
a :: Int
\end{lstlisting}

\subsection{データ構造}
同じ型の値を一方向に並べ, 前の要素が後の要素のポインタをもつようにしたデータ構造を{\bf リスト}という.
一方, リストに対して, 異なる型を含むことを許容するデータ構造を{\bf タプル}という.

\subsection{データ型}
例として\verb|Red|, \verb|Green|, \verb|Blue|からなるデータ\verb|Color|の宣言は以下のように記述する.
\begin{lstlisting}
data Color = Red | Green | Blue 
\end{lstlisting}
\begin{comment}
データを表示するためには, \verb|Color| を型クラス \verb|Show| のインスタンスにする必要があることに注意する.
\begin{lstlisting}
data Color = Red | Green | Blue deriving Show
\end{lstlisting}
\end{comment}
\begin{comment}
\subsection{型クラス}
\begin{lstlisting}
class Foo a where
    foo :: a -> String
instance Foo Bool where
    foo True = "Bool: True"
    foo False = "Bool: False"
instance Foo Int where
    foo x = "Int: " ++ show x
instance Foo Char where
    foo x = "Char: " ++ [x]

main = do
    putStrLn $ foo True		-- Bool: True
    putStrLn $ foo (123::Int)	-- Int: 123
    putStrLn $ foo 'A'		-- Char: A
\end{lstlisting}
Foo 型クラスは任意の型(a)を受け取り、Stringを返却するメソッド foo を持っている. instance を用いてそれぞれの型が引数に指定された場合の処理を実装している.
\subsection{型構築子}
また, 一つ以上の具体的な型に対して, 型構築子を適用すると新しい型を構築できる.
Maybe の定義は,
\begin{lstlisting}
data Maybe a = Nothing | Just a
data Maybe a = Nothing | Just a         
instance Eq a => Eq (Maybe a) 
instance Monad Maybe 
instance Functor Maybe 
instance Ord a => Ord (Maybe a) 
instance Read a => Read (Maybe a) 
instance Show a => Show (Maybe a) 
instance Applicative Maybe 
instance Foldable Maybe 
instance Traversable Maybe 
instance Monoid a => Monoid (Maybe a) 
\end{lstlisting}
Maybe は型構築子で Nothing および Just はデータ構築子です。
\end{comment}

\section{Hask}
\subsection{Haskに関する数学的な概念}\begin{Def}
{\bf 始対象}
\end{Def}
\begin{Def}
{\bf 終対象}
\end{Def}
\begin{Def}
{\bf　冪対象}
\end{Def}
\begin{Def}
圏$\mathscr{C}$が次の条件を満たすとき{\bf 圏$\mathscr{C}$はデカルト閉圏である}という.
\begin{enumerate}
\item
$\mathscr{C}$は終対象を持つ。
\item
任意の$X\in\mathrm{Obj}(\mathscr{C}),Y\in\mathrm{Obj}(\mathscr{C})$ に対して,
$X\times Y\in\mathrm{Obj}(\mathscr{C})$である.
\item
任意の$X\in\mathrm{Obj}(\mathscr{C}),Y\in\mathrm{Obj}(\mathscr{C})$に対して
$ZY\in\mathrm{Obj}(\mathscr{C})$である.
\end{enumerate}
\end{Def}
\begin{Def}
{\bf 多相関数}
\end{Def}
\subsection{Hask (\S 4に挿入)}

\begin{Prop}
Haskellの型全体の集合と,
それらの間の関数の集合の組は
デカルト閉圏をなす.
\end{Prop}


\subsection{List関手(\S 5に挿入)}



\begin{Prop}
Haskellにおける型構築子\verb|[]|は, HaskからHaskへの対象関数である.
\end{Prop}
\begin{proof}
型構築子\verb|[]|は, 任意の型\verb|A|に対して型\verb|[A]|を対応させるので, 命題が成り立つ.
\end{proof}

型\verb|A|と型\verb|B|および関数\verb|f::A->B|が与えられとき\verb|map f::[A]->[B]|が決定される.
\begin{Prop}
\verb|map|はHaskからHaskへの射関数である.
\end{Prop}
\begin{Prop}
型構築子\verb|[]|と\verb|map|がHaskからHaskへの関手をなす.
\end{Prop}
\begin{proof}
命題...と命題...より明らか.
\end{proof}
型構築子\verb|[]|を{\bf List関手}\index{りすとかんしゅ@List関手}という.
\subsubsection{Maybe関手}
Haskellにおける型構築子\verb|Maybe|は...

...

型構築子\verb|Maybe|は{\bf Maybe関手}\index{めいびーかんしゅ@Maybe関手}
と呼ばれる.
\subsubsection{Tree関手}
一般に木構造を生成する型構築子は関手にできる. これを{\bf Tree関手}と呼ぶ.

\lstinputlisting{../hssrc/Tree.hs}
\section{２変数の関手}
{\bf Hom関手}
\lstinputlisting{../hssrc/homfunctors.hs}
\section{型クラスとHaskの部分圏}
{\bf ソート関手}
\lstinputlisting{../hssrc/sort.hs}
